<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css2?family=Commissioner&family=Roboto:wght@300&display=swap" rel="stylesheet">    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
    <link href="../styles/style.css" rel="stylesheet">
    
    <title>Dynamic array | Data Structures and Algorithms Manual</title>    
  </head>
  <body class="container language-java line-numbers">    
    <nav class="wide">
      <ol>
        <li><a href="../index.html" class="home-page-link">DATA STRUCTURES AND ALGORITHMS</a></li>
        <li><a href="../introduction.html" class="nav-menu-section-item">Introduction</a></li>
        <li><a href="../computational-complexity.html" class="nav-menu-section-item">Computational complexity</a></li>
        <li class="nav-menu-header-item">
          Data structures
          <ol>
            <li><a href="data-structures-overview.html" class="nav-menu-section-item">Data structures overview</a></li>
            <li><a href="array.html" class="nav-menu-section-item">Array</a></li>
            <li><a href="dynamic-array.html" class="nav-menu-section-item">Dynamic array</a></li>        
          </ol>
        </li>        
        <li class="nav-menu-header-item">
          Algorithms
          <ol>
            <li><a href="../algorithms/algorithms-overview.html" class="nav-menu-section-item">Algorithms overview</a></li>        
            <li><a href="../algorithms/binary-search.html" class="nav-menu-section-item">Binary search</a></li> 
          </ol>
        </li>        
      </ol>
    </nav>

    <main>
      <nav class="narrow">
        <a href="../index.html" class="home-page-link">DATA STRUCTURES AND ALGORITHMS</a>
      </nav>
      <nav class="narrow">
        <a href="array.html" class="left-nav-link">PREVIOUS</a>
        <a href="../algorithms/algorithms-overview.html" class="right-nav-link">NEXT</a>
      </nav>
      <h1>Dynamic array</h1>
      <p>
        As we saw in the <a href="array.html">section on arrays</a>, static arrays aren't able to grow or shrink in 
        size. Dynamic arrays are used to overcome this limitation.
      </p>

      <h2>What is a dynamic array?</h2>
      <p>
        A dynamic array is an array that is able to shrink and grow in size. As with a static array, it allows updating 
        of values, but it also allows the user to delete values, append new values and insert new values. A common way to 
        implement a dynamic array is to use a static array. Let's look at how appending, inserting and searching for a value 
        work with a dynamic array built on top of a static array. 
      </p>
      
      <h2>Appending an element</h2>
      <p>
        To implement a dynamic array using a static array, we typically start with a static array of a particular capacity, 
        say four. When we want to append the first value, we append it to the next empty slot in the array. What happens 
        when the array is full, though?
      </p>
      <p>
        When the array is full, we create a new, larger array, copy over the elements from the previous array and then append the 
        new value. We can choose how large the new array is going to be. One common strategy is to double the capacity of the 
        previous array. So now our array has a capacity of eight and contains five elements. The number of elements actually stored 
        in the array is usually referred to as the "size" of the array. 
      </p>
      <p>
        So what's the time complexity of appending an element to a dynamic array? It depends. In most cases, the capacity of the 
        array will be greater than the size, so the time complexity will be constant. Simply append the new element to the next 
        available slot. When the size equals the capacity, though, a new array of double the capacity is created and each 
        element from the previous array is copied over to the new array. Then, finally, the new element is appended to the 
        new array. 
      </p>
      
      <!-- It would be good to show how the geometric series evaluates to 2n - 1. -->
      <p>
        To reason about the time complexity of this, suppose first that the initial array has a capacity of 1, 
        that we double the array capacity when it needs to be increased and that we make a total of 
        <math><mi>n</mi></math> appends. 
        Most of the appends will take constant time, but some will take longer. Which ones take longer? It will be 
        the ones where the array size is a power of two: 1, 2, 4, 8 and so on. Each time the capacity is doubled from 
        <math><mi>x</mi></math> to 
        <math>
          <mrow>
            <mn>2</mn>
            <mi>x</mi>
          </mrow>
        </math>,        
        <math><mi>x</mi></math> elements are copied from the previous array to the new array. So, to append a total of 
        <math>
          <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </math>        
        elements to the array, we make roughly 
        <math>
          <mrow>
            <mi>n</mi>
            <mspace width=".2em" />
            <mo>+</mo>            
            <mspace width=".2em" />
            <mi>n</mi>
            <mo>/</mo>
            <mn>2</mn>
            <mspace width=".2em" />
            <mo>+</mo>
            <mspace width=".2em" />
            <mi>n</mi>
            <mo>/</mo>
            <mn>4</mn>
            <mspace width=".2em" />
            <mo>+</mo>
            <mspace width=".2em" />
            &#x2026;
            <mspace width=".2em" />
            <mo>+</mo>
            <mspace width=".2em" />
            <mn>1</mn>
          </mrow>
        </math>        
        copies. It's "roughly" because <math><mi>n</mi></math> might not be 
        a strict power of two. This is a geometric series which evaluates to 
        <math>
          <mrow>
            <mn>2</mn>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
        </math>.
        That's 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>
        steps for the copies. 
        Add this to the 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>        
        steps needed to do the actual 
        <math>
          <mrow>                        
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </math>
        appends and we have a total time complexity of 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>        
        for appending 
        <math>
          <mrow>                        
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </math>
        elements to the dynamic array. If we evenly spread out this cost over the 
        <math>
          <mrow>                        
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </math>
        items, we 
        get an average cost of about 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>1</mi>
            <mo>)</mo>
          </mrow>
        </math>
        for appending a single item, which is often referred to as the amortised 
        time complexity of appending an element to a dynamic array. See <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms, Third Edition</a>
        for a more formal 
        treatment of amortised analysis.
      </p>
      
      <h2>Inserting an element</h2>
      <p>
        Inserting an element into a dynamic array is a bit different to appending an element. In addition to the amortised 
        constant-time append of the element, we'll need to shift over some other elements in order to make room 
        for the new element. If there are previously <math><mi>n</mi></math> elements in the array, 
        in the worst case, we'll need to shift the majority of them into their new correct positions before inserting the new element. 
        The entire time complexity of inserting an element is linear, or 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>.        
      </p>

      <h2>Deleting an element</h2>
      <p>
        To delete an element from an array of size <math><mi>n</mi></math>, we'll create a new array of size one less than the previous array and 
        copy over all the previous elements except the one to be deleted into the new array. This will take 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>
        time.
      </p>

      <h2>Space complexity</h2>
      <p>
        How about the space complexity of appending <math><mi>n</mi></math> elements to a dynamic array?
        Suppose, again that the initial capacity of the array is one and that we double the 
        capacity each time it's reached. Then appending <math><mi>n</mi></math> elements requires roughly 
        <math>
          <mrow>
            <mn>1</mn>
            <mo>+</mo>
            <mn>2</mn>
            <mo>+</mo>
            <mn>4</mn>
            <mo>+</mo>
            <mn>8</mn>
            <mo>+</mo>
            &#x2026;
            <mo>+</mo>
            <mi>n</mi>
          </mrow>
        </math>
        units of space. 
        This is the same geometric series encountered when appending items to the array and it equals 
        <math>
          <mrow>
            <mn>2</mn>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
        </math>.
        Therefore, 
        appending <math><mi>n</mi></math> items has a space complexity of 
        <math>
          <mrow>
            <mi>O</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
          </mrow>
        </math>. 
      </p>

      <h2>Implementation</h2>
      <p id="dynamic-array-constructors-description">
        We'll start our Java implementation of a dynamic array with the class constructors.
      </p>

      <figure>        
        <figcaption id="dynamic-array-constructors-caption">
          Dynamic array constructors
        </figcaption>
        <button type="button" 
                data-clipboard-target="#dynamic-array-constructors"
                class="copy-code-button"
                id="dynamic-array-constructors-code-button">Copy code</button>
        <pre 
          aria-labelledby="dynamic-array-constructors-caption" 
          aria-describedby="dynamic-array-constructors-description"><code contenteditable spellcheck="false" id="dynamic-array-constructors">@SuppressWarnings("unchecked")
public class DynamicArray&lt;E&gt; {
  private E[] array;
  private int size = 0;
  private int capacity = 0;

  DynamicArray() {
    this(10);
  }

  DynamicArray(int initialCapacity) {
    if (initialCapacity &lt;= 0) {
      throw new IllegalArgumentException("Initial capacity must be > 0; got: " +
        initialCapacity);
    }
    array = (E[]) new Object[initialCapacity];
    capacity = initialCapacity;
  }
}</code></pre>        
      </figure>

      <p id="is-empty-and-size-description">
        Next, we'll add two small methods to check if the array is empty 
        and to return its size.
      </p>

      <figure>
        <figcaption id="is-empty-and-size-caption">
          Dynamic array isEmpty() and size() methods
        </figcaption>
        <pre
          aria-labelledby="is-empty-and-size-caption"
          aria-describedby="is-empty-and-size-description"><code contenteditable spellcheck="false">public boolean isEmpty() {            
  return size == 0;
}

public int size() {
  return size;
}</code></pre>
      </figure>
      
      <p id="dynamic-array-add-description">
        And now a method to add a new element to the end of the array.
      </p>

      <figure>
        <figcaption id="dynamic-array-add-caption">
          Dynamic array add() method
        </figcaption>
        <pre
          aria-labelledby="dynamic-array-add-caption"
          aria-describedby="dynamic-array-add-description"><code contenteditable spellcheck="false">public boolean add(E element) {
  if (size &lt; capacity) {
    array[size++] = element;
    return true;
  }
  
  capacity *= 2;
  E[] newArray = (E[]) new Object[capacity];
  for (int i = 0; i &lt; array.length; i++) {
    newArray[i] = array[i];
  }
  newArray[size++] = element;
  array = newArray;
  return true;
}</code></pre>
      </figure>

      <p id="get-method-description">
        Next up is a method to get an element at a particular index.
      </p>
      <figure>
        <figcaption id="get-method-caption">
          Dynamic array get() method
        </figcaption>
        <pre
          aria-labelledby="get-method-caption"
          aria-describedby="get-method-description"><code contenteditable spellcheck="false">public E get(int index) {
  if (index &lt; 0 || index &gt;= size) {
    throw new IndexOutOfBoundsException("Index is out of bounds; got: " + 
      index);
  }
  
  return array[index];
}</code></pre>
      </figure>

      <p id="set-method-description">
        And a method to set a particular index to a particular value:
      </p>
      <figure>
        <figcaption id="set-method-caption">
          Dynamic array set() method
        </figcaption>
        <pre
          aria-labelledby="set-method-caption"
          aria-describedby="set-method-description"><code contenteditable spellcheck="false">public E set(int index, E element) {            
  if (index &lt; 0 || index &gt;= size) {
    throw new IndexOutOfBoundsException("Index is out of bounds; got: " + 
      index);
  }
  E previousElement = array[index];
  array[index] = element;
  return previousElement;
}</code></pre>
      </figure>

      <p id="remove-method-description">
        And finally, a method to remove the element at a given 
        index from the array.
      </p>
      <figure>
        <figcaption id="remove-method-caption">
          Dynamic array remove() method
        </figcaption>
        <pre 
          aria-labelledby="remove-method-caption"
          aria-describedby="remove-method-description"><code contenteditable spellcheck="false">public E remove(int index) {            
  if (index &lt; 0 || index &gt;= size) {
    throw new IndexOutOfBoundsException("Index is out of bounds; got: " + 
      index);
  }
  E element = array[index];
  E[] newArray = (E[]) new Object[size - 1];
  for (int i = 0, j = 0; i &lt; size; i++, j++) {
    if (i == index) j--;
    else newArray[j] = array[i];
  }
  array = newArray;
  capacity = --size;
  return element;
}</code></pre>
      </figure>

      <nav>
        <a href="array.html" class="left-nav-link">PREVIOUS</a>
        <a href="../algorithms/algorithms-overview.html" class="right-nav-link">NEXT</a>
      </nav>
    </main>

    <footer>      
      <hr class="footer-top-rule">
      Crafted by Caleb Owusu-Yianoma - &copy; 2020
    </footer>

    <!-- A light MathML polyfill recommended by MDN -->
    <!-- See https://developer.mozilla.org/en-US/docs/Web/MathML/Authoring -->
    <script src="https://fred-wang.github.io/mathml.css/mspace.js"></script>
    
    <!-- Code syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="../script.js"></script>
  </body>
</html>

